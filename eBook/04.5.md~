# 4.5 Carga de archivos

Supongamos que usted tiene un sitio web como Instagram, y desea que los usuarios suban sus hermosas fotos, ¿qué vas a hacer?

Hay que añadir una propiedad `enctype` a la forma que desea utilizar para subir fotos, y hay tres posibilidades de su valor:

	application/x-www-form-urlencoded   Trans-coding all characters before upload(default).
	multipart/form-data   No trans-coding, you have to use this value when your form have file upload controls.
	text/plain    Convert spaces to "+", but no trans-coding for special characters.

Por lo tanto, el contenido HTML de un formulario para subir el archivo debe tener este aspecto:

	<html>
	<head>
    	<title>Upload file</title>
	</head>
	<body>
	<form enctype="multipart/form-data" action="http://127.0.0.1:9090/upload" method="post">
  		<input type="file" name="uploadfile" />
  		<input type="hidden" name="token" value="{{.}}"/>
  		<input type="submit" value="upload" />
	</form>
	</body>
	</html>

Tenemos que añadir una función en el lado del servidor para manejar este asunto.

	http.HandleFunc("/upload", upload)

	// upload logic
	func upload(w http.ResponseWriter, r *http.Request) {
    	fmt.Println("method:", r.Method)
    	if r.Method == "GET" {
        	crutime := time.Now().Unix()
        	h := md5.New()
        	io.WriteString(h, strconv.FormatInt(crutime, 10))
        	token := fmt.Sprintf("%x", h.Sum(nil))

        	t, _ := template.ParseFiles("upload.gtpl")
        	t.Execute(w, token)
    	} else {
        	r.ParseMultipartForm(32 << 20)
        	file, handler, err := r.FormFile("uploadfile")
        	if err != nil {
            	fmt.Println(err)
            	return
        	}
        	defer file.Close()
        	fmt.Fprintf(w, "%v", handler.Header)
        	f, err := os.OpenFile("./test/"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)
        	if err != nil {
            	fmt.Println(err)
            	return
        	}
        	defer f.Close()
        	io.Copy(f, file)
    	}
	}

Como puedes ver, tenemos que llamar a `r.ParseMultipartForm` para subir archivos, el argumento se entiende `maxMemory` . Después de que hayas llamado `ParseMultipartForm` , archivo se guardará en la memoria del servidor con `maxMemory` tamaño, si el tamaño del archivo es mayor que `maxMemory` , resto de datos se guarda en el archivo temporal del sistema. Usted puede utilizar `r.FormFile` para obtener el identificador de archivo y utilizar `io.Copy` y guardar en su sistema de archivos.

Usted no necesita llamar `r.ParseForm` cuando acceda a otros campos no de archivo en el formulario porque Ir llamará cuando es necesario. También llamada `ParseMultipartForm` una vez es suficiente, y no hubo diferencias de varias llamadas.

Utilizamos tres pasos para subir archivos de la siguiente manera:

Añadir enctype = "multipart / form-data" al formulario.
Llame r.ParseMultipartForm en el lado del servidor para guardar el archivo en la memoria o un archivo temporal.
Llame r.FormFile para obtener el identificador de archivo y guardar en el sistema de archivos.
El manejador de archivos es el multipart.FileHeader , usa siguiente estructura:

As you can see, we need to call `r.ParseMultipartForm` for uploading files, the argument means the `maxMemory`. After you called `ParseMultipartForm`, file will be saved in your server memory with `maxMemory` size, if the file size is larger than `maxMemory`, rest of data will be saved in system temporary file. You can use `r.FormFile` to get file handle and use `io.Copy` to save to your file system.

You don't need to call `r.ParseForm` when you access other non-file fields in the form because Go will call it when it's necessary. Also call `ParseMultipartForm` once is enough, and no differences for multiple calls.

We use three steps for uploading files as follows:

1. AñadirAdd `enctype="multipart/form-data"` a su form.
2. Llamar `r.ParseMultipartForm` en el lado del servidor para guardar el archivo en la memoria o un archivo temporal.
3. Llamar `r.FormFile` para obtener el identificador de archivo y guardar en el sistema de archivos.

The file handler is the `multipart.FileHeader`, it uses following struct:

	type FileHeader struct {
    	Filename string
    	Header   textproto.MIMEHeader
    	// contains filtered or unexported fields
	}

![](images/4.5.upload2.png?raw=true)

Figure 4.5 Print information in server after received file.

## Clients upload files

I showed the example of using form to upload file, and we can impersonate a client form to upload file in Go as well.

	package main

	import (
	    "bytes"
	    "fmt"
	    "io"
	    "io/ioutil"
	    "mime/multipart"
	    "net/http"
	    "os"
	)

	func postFile(filename string, targetUrl string) error {
	    bodyBuf := &bytes.Buffer{}
	    bodyWriter := multipart.NewWriter(bodyBuf)
	
	    // this step is very important
	    fileWriter, err := bodyWriter.CreateFormFile("uploadfile", filename)
	    if err != nil {
	        fmt.Println("error writing to buffer")
	        return err
	    }
	
	    // open file handle
	    fh, err := os.Open(filename)
	    if err != nil {
	        fmt.Println("error opening file")
	        return err
	    }
	
	    //iocopy
	    _, err = io.Copy(fileWriter, fh)
	    if err != nil {
	        return err
	    }
	
	    contentType := bodyWriter.FormDataContentType()
	    bodyWriter.Close()
	
	    resp, err := http.Post(targetUrl, contentType, bodyBuf)
	    if err != nil {
	        return err
	    }
	    defer resp.Body.Close()
	    resp_body, err := ioutil.ReadAll(resp.Body)
	    if err != nil {
	        return err
	    }
	    fmt.Println(resp.Status)
	    fmt.Println(string(resp_body))
	    return nil
	}

	// sample usage
	func main() {
	    target_url := "http://localhost:9090/upload"
	    filename := "./astaxie.pdf"
	    postFile(filename, target_url)
	}

The above example shows you how to use client to upload file, it uses `multipart.Write` to write file in cache and sends to server through POST method.

If you have other field need to write into data like user name, call `multipart.WriteField` as needed.

## Links

- [Directory](preface.md)
- Previous section: [Duplicate submissions](04.4.md)
- Next section: [Summary](04.6.md)
