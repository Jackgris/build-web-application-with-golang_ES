# 4.3 Cross site scripting

Los sitios web de hoy tienen mucho más contenido dinámico con el fin de mejorar la experiencia del usuario, lo que significa que podemos ofrecer información dinámica depende de la conducta de cada individuo. Sin embargo, hay una cosa que se llama "secuencias de comandos entre sitio" (conocido como "XSS") siempre atacando sitios web dinámicos, y los sitios web estáticos son completamente bien en este momento.

Los atacantes suelen inyectar scripts maliciosos como JavaScript, VBScript, ActiveX o Flash en los sitios web que tienen lagunas. Una vez que tengan la inyección de éxito, su información de usuario será robada y su sitio web se llena de correo no deseado, también se puede cambiar la configuración del usuario para lo que quieran.

Si desea evitar este tipo de ataque, es mejor combinar los dos enfoques siguientes:

- Verificación de todos los datos de los usuarios, lo que hemos hablado acerca de la sección anterior.
- Dar un tratamiento especial para los datos que se respondieron a los clientes, con el fin de prevenir cualquier script inyectado se ejecuta en los navegadores.

Entonces, ¿cómo le vamos a hacer estos dos puestos de trabajo en Go? Afortunadamente, el paquete de `html/template` tiene algunas funciones útiles para escapar de los datos de la siguiente manera:

- `func HTMLEscape(w io.Writer, b []byte)` escapes b to w.
- `func HTMLEscapeString(s string) string` returns string after escaped from s.
- `func HTMLEscaper(args ...interface{}) string` returns string after escaped from multiple arguments.

Vamos a cambiar el ejemplo de la sección 4.1:

	fmt.Println("username:", template.HTMLEscapeString(r.Form.Get("username"))) // print at server side
	fmt.Println("password:", template.HTMLEscapeString(r.Form.Get("password")))
	template.HTMLEscape(w, []byte(r.Form.Get("username"))) // responded to clients

If we try to input user name as `<script>alert()</script>`, we will see following content in the browser:

![](images/4.3.escape.png?raw=true)

Figure 4.3 JavaScript after escaped

Functions in package `html/template` help you escape all HTML tags, what if you just want to print `<script>alert()</script>` to browsers? You should use `text/template` instead.

	import "text/template"
	...
	t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
	err = t.ExecuteTemplate(out, "T", "<script>alert('you have been pwned')</script>")

Output:

	Hello, <script>alert('you have been pwned')</script>!

Or you can use type `template.HTML`: 
Variable content will not be escaped if it's type is `template.HTML`.

	import "html/template"
	...
	t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
	err = t.ExecuteTemplate(out, "T", template.HTML("<script>alert('you have been pwned')</script>"))

Output:

	Hello, <script>alert('you have been pwned')</script>!

One more example of escape

	import "html/template"
	...
	t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
	err = t.ExecuteTemplate(out, "T", "<script>alert('you have been pwned')</script>")

Output:

	Hello, &lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;!

## Links

- [Directory](preface.md)
- Previous section: [Verification of inputs](04.2.md)
- Next section: [Duplicate submissions](04.4.md)
