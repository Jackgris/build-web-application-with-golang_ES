# 4.2 Verification of inputs

El principio más importante en el desarrollo web es que no se puede confiar en nada de formulario de usuario, usted tiene que verificar todos los datos antes de usarlos. Usted puede saber muchas páginas web son invadidas por este problema, que es simple, pero crucial.

Hay dos maneras de verificar los datos de forma que comúnmente utilizado, el que es la verificación JavaScript en front-end, y otra es la verificación del servidor de back-end. En esta sección, vamos a hablar de la comprobación del servidor en el desarrollo web.

## Required fields

A veces le preguntas a los usuarios de entrada de algunos campos, pero que no lo hace, por ejemplo, que necesita nombre de usuario en la sección anterior. Puede utilizar la función `len` para obtener la longitud de campo de entrada de informacion de los usuarios.

	if len(r.Form["username"][0])==0{
    	// code for empty field
	}

`r.Form` utiliza diferentes tratamientos de diferentes tipos de elementos de formulario cuando son espacios en blanco. Para la caja de texto vacío, área de texto y archivo de carga, devuelve cadena vacía; casilla de verificación y botón de radio, ni siquiera crear elementos correspondientes, y obtendrá los errores si se intenta acceder a él. Por lo tanto, será mejor que usamos `r.Form.Get()` para obtener los valores presentados porque siempre vuelve vacía si el valor no existe. Por otro lado, `r.Form.Get()` sólo puede obtener un valor de campo cada vez, así que tienes que usar `r.Form` para obtener valores en un map.

## Numbers

A veces sólo se necesita un número para el valor del campo. Por ejemplo, usted necesita la edad de los usuarios, al igual que 50 o 10, en lugar de "la edad suficiente" o "joven". Si necesitamos números positivos, podemos convertir a tipo int primero y procesarlos.

	getint,err:=strconv.Atoi(r.Form.Get("age"))
	if err!=nil{
    	// Error se produce cuando se convierte a Number, no puede un número
	}

	// verificación de número
	if getint >100 {
    	// too big
	}

Otra forma de hacerlo es usando la expresión regular.

	if m, _ := regexp.MatchString("^[0-9]+$", r.Form.Get("age")); !m {
    	return false
	}
	
Con fines de alto rendimiento, la expresión regular no es una manera eficiente, pero la expresión regular simple es lo suficientemente rápido. Si sabes expresión regular antes, usted debe es una forma muy conveniente para verificar los datos. Observe que Go utiliza [RE2](http://code.google.com/p/re2/wiki/Syntax) , se admiten todos los caracteres UTF-8.

## Chinese

A veces necesitamos a los usuarios introducir su nombre chino, tenemos que verificar que utilizan todos los chinos en lugar de caracteres aleatorios. Para la verificación de China, la expresión regular es la única manera.

	if m, _ := regexp.MatchString("^[\\x{4e00}-\\x{9fa5}]+$", r.Form.Get("realname")); !m {
    	return false
	}

## English letters

Sometimes we need users to input English letters. For example, we need someone's English name, like astaxie instead of asta谢. We can easily use regular expression to do verification.

	if m, _ := regexp.MatchString("^[a-zA-Z]+$", r.Form.Get("engname")); !m {
    	return false
	}

## E-mail address

If you want to know if users input valid E-mail address, you can use following regular expression:

	if m, _ := regexp.MatchString(`^([\w\.\_]{2,10})@(\w{1,}).([a-z]{2,4})$`, r.Form.Get("email")); !m {
    	fmt.Println("no")
	}else{
    	fmt.Println("yes")
	}

## Drop down list

When we need item in our drop down list, but we get some values that are made by hackers, how can we prevent it? 

Suppose we have following `<select>`:

	<select name="fruit">
	<option value="apple">apple</option>
	<option value="pear">pear</option>
	<option value="banane">banane</option>
	</select>

Then, we use following way to verify:

	slice:=[]string{"apple","pear","banane"}

	for _, v := range slice {
    	if v == r.Form.Get("fruit") {
        	return true
    	}
	}
	return false

All functions I showed above are in my open source project for operating slice and map: [https://github.com/astaxie/beeku](https://github.com/astaxie/beeku)

## Radio buttons

If we want to know the user is male or female, we may use a radio button, return 1 for male and 2 for female. However, there is a little boy is reading book about HTTP, and send to you 3, will your program have exception? So we need to use same way for drop down list to make sure all values are expected.

	<input type="radio" name="gender" value="1">Male
	<input type="radio" name="gender" value="2">Female

And we use following code to do verification:

	slice:=[]int{1,2}

	for _, v := range slice {
    	if v == r.Form.Get("gender") {
        	return true
    	}
	}
	return false

## Check boxes

Suppose there are some check boxes for users' interests, and you don't want extra values as well.

	<input type="checkbox" name="interest" value="football">Football
	<input type="checkbox" name="interest" value="basketball">Basketball
	<input type="checkbox" name="interest" value="tennis">Tennis

Here is a little bit different in verification between radio buttons and check boxes because we get a slice from check boxes.

	slice:=[]string{"football","basketball","tennis"}
	a:=Slice_diff(r.Form["interest"],slice)
	if a == nil{
    	return true
	}

	return false 

## Date and time

Suppose you want to make users input valid date or time. Go has package `time` to convert year, month, day to corresponding time, then it's easy to check it.

	t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	fmt.Printf("Go launched at %s\n", t.Local())

After you had time, you can use package `time` for more operations depend on your purposes.

We talked about some common form data verification in server side, I hope you understand more about data verification in Go, especially how to use regular expression.

## Links

- [Directory](preface.md)
- Previous section: [Process form inputs](04.1.md)
- Next section: [Cross site scripting](04.3.md)
